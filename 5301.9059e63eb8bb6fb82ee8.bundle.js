/*! For license information please see 5301.9059e63eb8bb6fb82ee8.bundle.js.LICENSE.txt */
(self.webpackChunkkui_shell=self.webpackChunkkui_shell||[]).push([[5301,1758],{76489:(e,n)=>{"use strict";n.Q=function(e,n){if("string"!=typeof e)throw new TypeError("argument str must be a string");for(var i={},s=n||{},c=e.split(o),d=s.decode||t,l=0;l<c.length;l++){var u=c[l],a=u.indexOf("=");if(!(a<0)){var h=u.substr(0,a).trim(),v=u.substr(++a,u.length).trim();'"'==v[0]&&(v=v.slice(1,-1)),null==i[h]&&(i[h]=r(v,d))}}return i};var t=decodeURIComponent,i=encodeURIComponent,o=/; */,s=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;function r(e,n){try{return n(e)}catch(n){return e}}},95233:(e,n,t)=>{"use strict";t.d(n,{kQ:()=>l,IJ:()=>u,hV:()=>a});var i=t(11227),o=t.n(i),s=t(17187),r=t(82208),c=function(e,n,t,i){return new(t||(t=Promise))((function(o,s){function r(e){try{d(i.next(e))}catch(e){s(e)}}function c(e){try{d(i.throw(e))}catch(e){s(e)}}function d(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(r,c)}d((i=i.apply(e,n||[])).next())}))};const d=o()("plugins/bash-like/pty/channel");var l;!function(e){e[e.CONNECTING=0]="CONNECTING",e[e.OPEN=1]="OPEN",e[e.CLOSING=2]="CLOSING",e[e.CLOSED=3]="CLOSED"}(l||(l={}));class u extends s.EventEmitter{constructor(e){super(),this.readyState=l.OPEN,this.otherSide=e||new u(this)}init(){return c(this,void 0,void 0,(function*(){d("IPC init"),yield(0,r.onConnection)(yield(0,r.disableBashSessions)())(this.otherSide),this.emit("open"),d("IPC init done")}))}close(){}send(e){if(this.otherSide.readyState===l.OPEN)try{this.otherSide.emit("message",e)}catch(e){console.error(e)}}removeEventListener(e,n){this.off(e,n)}}class a extends s.EventEmitter{constructor(){super(...arguments),this.readyState=l.OPEN}init(){return c(this,void 0,void 0,(function*(){d("IPC init");const{body:e}=yield window["webview-proxy"]({command:"init",provider:"pty",channel:this});this.channelId=e.channelId,console.log(`CHANNELID ${this.channelId}`),this.emit("open"),d("IPC init done")}))}close(){this.emit("exit")}send(e){console.log(`SEND ${this.channelId}`),window["webview-proxy"]({command:"send",provider:"pty",channelId:this.channelId,body:e})}removeEventListener(e,n){this.off(e,n)}}},82208:(e,n,t)=>{"use strict";t.r(n),t.d(n,{disableBashSessions:()=>k,getLoginShell:()=>O,getShellOpts:()=>C,setShellAliases:()=>I,onConnection:()=>P,main:()=>H,default:()=>J});var i=t(11227),o=t.n(i),s=t(12993),r=t(89539),c=t(26470),d=t(32383),l=t(79267),u=t(76489),a=t(53462),h=t(51173),v=t(48764).Buffer,f=t(7716),p=function(e,n,t,i){return new(t||(t=Promise))((function(o,s){function r(e){try{d(i.next(e))}catch(e){s(e)}}function c(e){try{d(i.throw(e))}catch(e){s(e)}}function d(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(r,c)}d((i=i.apply(e,n||[])).next())}))};const y=o()("plugins/bash-like/pty/server");let w=8083;const m=[],g=e=>({req:n},t)=>{const i=(0,u.Q)(n.headers.cookie||""),o=i[e.key];if(o)try{const n=JSON.parse(v.from(o,"base64").toString("utf-8"));if(n.token===e.session.token)return void t(!0);console.error("token found, but mismatched values",e,n)}catch(e){console.error("error parsing session token",o,e)}console.error("invalid session for websocket upgrade",e,i[e.key],i),t(!1,401,"Invalid authorization for websocket upgrade")};let S;const b=()=>(0,c.join)(f.env.HOME,".bash_sessions_disable"),x=()=>p(void 0,void 0,void 0,(function*(){yield(0,r.promisify)(s.unlink)(b())})),k=()=>p(void 0,void 0,void 0,(function*(){return"darwin"!==f.platform||(void 0===S&&(S=yield(0,r.promisify)(s.exists)(b())),S)?()=>p(void 0,void 0,void 0,(function*(){})):(yield(e=>{const n=(0,r.promisify)(s.open),t=(0,r.promisify)(s.close);return n(e,"w").then(t)})(b()),x)}));let E;const O=()=>new Promise(((e,n)=>{if(E)y("returning cached login shell",E),e(E);else if(f.env.SHELL)e(f.env.SHELL);else{const t="win32"===f.platform?"powershell.exe":"/bin/bash";if(void 0!==f.env.TRAVIS_JOB_ID||"win32"===f.platform)y("using defaultShell for travis"),E=t,e(E);else try{(0,d.exec)(`${t} -l -c "echo $SHELL"`,((i,o,s)=>p(void 0,void 0,void 0,(function*(){i?(console.error("error in getLoginShell subroutine",i),s&&console.error(s),n(i)):(E=o.trim()||t,y("login shell",E),e(E))}))))}catch(n){console.error("error in exec of getLoginShell subroutine",n),e(t)}}}));function C(){return p(this,void 0,void 0,(function*(){const e=(yield t.e(8118).then(t.bind(t,14178))).default,n="win32"===f.platform?void 0:["--rcfile",yield e,"-i","-c","--"],i=yield t.e(9599).then(t.t.bind(t,69599,19)).catch((()=>{})),o=i&&i.shellExe||"",s=i&&i.shellOpts||[];return{shellExe:o||("win32"===f.platform?"powershell.exe":"/bin/bash"),shellOpts:s&&Array.isArray(s)&&s.length>0?s:"win32"===f.platform?[]:n}}))}let N={};function I(e){N=e}const P=(e,n,i)=>o=>p(void 0,void 0,void 0,(function*(){y("onConnection",n,i,o);const{spawn:s}=yield Promise.resolve().then(t.t.bind(t,27690,23)),r={},c={};o.on("message",(d=>p(void 0,void 0,void 0,(function*(){try{const l=JSON.parse(d);switch(l.type){case"xon":{const e=l.uuid&&(yield r[l.uuid]);if(e){const n="";e.write(n)}const n=l.uuid&&c[l.uuid];n&&n.xon();break}case"xoff":{const e=l.uuid&&(yield r[l.uuid]);if(e){const n="";e.write(n)}const n=l.uuid&&c[l.uuid];n&&n.xoff();break}case"kill":{const n=l.uuid&&(yield r[l.uuid]);if(n)return n.kill(l.signal||"SIGHUP"),e(l.exitCode||0);const t=l.uuid&&c[l.uuid];y(`kill requested. hasShell=${void 0!==n} hasJob=${void 0!==t}`),t&&(t.abort(),c[l.uuid]=void 0);break}case"exit":return e(l.exitCode||0);case"request":{const{internalBeCarefulExec:e}=yield Promise.resolve().then(t.bind(t,51173));l.env&&(f.env=l.env);const n=e=>{o.send(e)},i=Object.assign({},l.execOptions,{rethrowErrors:!0});l.stream&&(y("initializing streaming exec",l.uuid),i.onInit=e=>(c[l.uuid]=e,e=>o.send(JSON.stringify({type:"chunk",uuid:l.uuid,chunk:e}))));try{const t=yield e(l.cmdline,i);y("got response"),n(JSON.stringify({type:"object",uuid:l.uuid,response:t}))}catch(e){y("got error",e.message);const t=e;n(JSON.stringify({type:"object",uuid:l.uuid,response:{code:t.code||t.statusCode,statusCode:t.statusCode,message:t.message,stack:t.stack}}))}break}case"exec":r[l.uuid]=new Promise(((e,t)=>p(void 0,void 0,void 0,(function*(){try{const t=Object.assign({},f.env,l.env,{KUI:"true"});!f.env.DEBUG||l.env&&l.env.DEBUG||delete t.DEBUG,t.HOME&&(t.HOME=(0,h.expandHomeDir)(t.HOME));const c=l.cmdline.indexOf(" "),d=l.cmdline.slice(0,c<0?l.cmdline.length:c),u=N[d],a=u?l.cmdline.replace(new RegExp(`^${d}`),u):l.cmdline,{shellExe:v,shellOpts:p}=yield C();let y=s(v,p.concat([a]),{uid:n,gid:i,name:"xterm-color",rows:l.rows,cols:l.cols,cwd:l.cwd||f.cwd(),env:t});y.on("data",(e=>{o.send(JSON.stringify({type:"data",data:e,uuid:l.uuid}))})),y.on("exit",(e=>{y=void 0,l.uuid&&delete r[l.uuid],o.send(JSON.stringify({type:"exit",exitCode:e,uuid:l.uuid}))})),o.send(JSON.stringify({type:"state",state:"ready",uuid:l.uuid})),e(y)}catch(e){console.error("could not exec",e),t(e)}}))));break;case"data":try{const e=l.uuid&&(yield r[l.uuid]);if(e)return e.write(l.data);console.error("could not write to the shell, as we had no uuid, or no matching shell instance",l.uuid,l.data)}catch(e){console.error("could not write to the shell",e)}break;case"resize":try{const e=l.uuid&&(yield r[l.uuid]);if(e)return e.resize(l.cols,l.rows);console.error("could not resize pty, as we had no uuid, or no matching shell instance",l.uuid)}catch(e){console.error(`error in resize ${l.cols} ${l.rows}`),console.error("could not resize pty",e)}}}catch(e){console.error(e)}}))))}));let L,D;const H=(e,n,i,o)=>p(void 0,void 0,void 0,(function*(){if(L)return D;{const r=yield Promise.resolve().then(t.t.bind(t,22439,23));return new Promise((c=>p(void 0,void 0,void 0,(function*(){const d=m.length,u=yield k(),a=e=>p(void 0,void 0,void 0,(function*(){yield u(e);const{wss:n,server:t}=m.splice(d,1)[0];n.close(),t&&t.close()}));if(i){const t=new r.Server({noServer:!0,verifyClient:o&&g(o)});m.push({wss:t});const i=(o,s,r)=>{const c=o.url.match(/\/bash\/([0-9a-z-]+)/);(c&&c[1])===e&&(n.removeListener("upgrade",i),t.handleUpgrade(o,s,r,(function(e){t.emit("connection",e,o)})))};n.on("upgrade",i),c({wss:t,port:D,exitNow:a})}else{D=yield new Promise(((e,n)=>p(void 0,void 0,void 0,(function*(){const{createServer:i}=yield Promise.resolve().then(t.t.bind(t,11631,23)),o=()=>{const t=w;w+=1;const s=i();s.listen(t,(()=>{s.once("close",(function(){e(t)})),s.close()})),s.on("error",(e=>{"EADDRINUSE"===e.code?o():n(e)}))};o()}))));const e=(0,l.createServer)({key:s.readFileSync(".keys/key.pem","utf8"),cert:s.readFileSync(".keys/cert.pem","utf8"),passphrase:f.env.PASSPHRASE,requestCert:!1,rejectUnauthorized:!1});e.listen(D,(()=>p(void 0,void 0,void 0,(function*(){const n=L=new r.Server({server:e});m.push({wss:L,server:e}),c({wss:n,port:D,exitNow:a})}))))}})))).then((({wss:e,port:n,exitNow:t})=>(o||(y("listening for connection"),e.on("connection",P(t,o&&o.session.uid,o&&o.session.gid))),{wss:e,port:n})))}})),J=e=>{e.listen("/bash/websocket/stdio",(()=>new Promise(((e,n)=>p(void 0,void 0,void 0,(function*(){try{yield(new a.h).init((()=>{y("done with stdiochannel"),e(!0)}))}catch(e){n(e)}}))))),{requiresLocal:!0}),e.listen("/bash/websocket/open",(()=>{throw new Error("Unsupported operation")}),{requiresLocal:!0})}},53462:(e,n,t)=>{"use strict";t.d(n,{h:()=>v});var i=t(11227),o=t.n(i),s=t(17187),r=t(82208),c=t(95233),d=t(7716),l=function(e,n,t,i){return new(t||(t=Promise))((function(o,s){function r(e){try{d(i.next(e))}catch(e){s(e)}}function c(e){try{d(i.throw(e))}catch(e){s(e)}}function d(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(r,c)}d((i=i.apply(e,n||[])).next())}))};o()("plugins/bash-like/pty/stdio-channel-proxy-stderr");const u=o()("plugins/bash-like/pty/stdio-channel-proxy"),a=o()("plugins/bash-like/pty/stdio-channel-kui"),h="\n";class v extends s.EventEmitter{constructor(){super(...arguments),this.readyState=c.kQ.OPEN}init(e){return l(this,void 0,void 0,(function*(){a("StdioChannelKuiSide.init"),yield(0,r.onConnection)(e)(this);let n="";d.stdin.on("data",(e=>{const t=e.lastIndexOf(h);if(t<0)return void(n+=e);const i=n+e.slice(0,t).toString();n=t<0?"":e.slice(t).toString(),i.split(h).filter((e=>e)).forEach((e=>{a("input",e),this.emit("message",e)}))})),this.send("open")}))}close(){u("closing stdio channel"),this.emit("close")}send(e){if(this.readyState===c.kQ.OPEN)try{d.stdout.write(`${e}\n`)}catch(e){console.error("error in process write",e)}}removeEventListener(e,n){this.off(e,n)}}},61758:()=>{}}]);